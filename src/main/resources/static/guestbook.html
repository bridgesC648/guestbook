<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Christopher and Raymond's Musical Guestbook</title>
    <style>
        /* Center all content */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: sans-serif;
        }
        h1, h2 {
            text-align: center;
            margin-bottom: 5px;
        }
        #staffContainer {
            position: relative;
            margin-bottom: 10px;
            text-align: center;
        }
        #staffCanvas {
            border: 1px solid #ccc;
            touch-action: none;
            margin: 0 auto;
            display: block;
        }
        /* Treble clef image (position as needed) */
        #trebleClef {
            position: absolute;
            left: 110px;
            top: 105px;
            height: 90px;
            opacity: 0.8;
            pointer-events: none;
        }
        #submitTitle {
            display: block;
            margin: 0 auto; /* centers the element */
            font-size: 1.5em;
            padding: 5px;
            width: 50%;
            text-align: center;
            border: 1px solid #ccc;
            background-color: #fff;
        }
        /* Controls row: song control buttons on left; note controls on right */
        #controlsRow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        /* Uniform style & height for song & note control buttons */
        #playControls button,
        #noteControls button {
            height: 40px;
            padding: 8px 16px;
            font-size: 1em;
            border: none;
            background-color: #007bff;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
        }
        #playControls button:hover,
        #noteControls button:hover {
            background-color: #0056b3;
        }
        /* Note controls remain in their own container */
        #noteControls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #noteControls label {
            font-weight: bold;
            margin-right: 5px;
        }
        #playControls label {
            font-weight: bold;
            margin-right: 5px;
        }
        /* Submission form (below controls): only name and comment with submit at bottom */
        #submissionFormContainer {
            margin-top: 20px;
            text-align: center;
        }
        #submissionForm {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        /* Force the name and comment inputs to be the same width */
        #submitName,
        #submitComment {
            width: 60%;
            box-sizing: border-box;
        }
        /* Ensure comment box uses sans-serif (not Courier) */
        #submitComment {
            font-family: sans-serif;
            height: 80px;
        }
        #submitName {
            padding: 5px;
        }
        #submissionForm button {
            padding: 8px 16px;
            font-size: 1em;
        }
        /* Submissions Table */
        #submissionsTableContainer {
            margin-top: 30px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 10px;
        }
        table, th, td {
            border: 1px solid #aaa;
        }
        th, td {
            padding: 4px;
            text-align: center;
            word-break: break-word;
        }
        /* Limit comment column to 50% of table width */
        #submissionsTable {
            table-layout: fixed;
        }
        #submissionsTable th:nth-child(1) { width: 20%; }
        #submissionsTable th:nth-child(2) { width: 20%; }
        #submissionsTable th:nth-child(3) { width: 50%; }
        #submissionsTable th:nth-child(4) { width: 10%; }
        /* Pagination Controls */
        #paginationControls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            gap: 10px;
        }
        /* Simple error styling */
        #submissionError {
            color: red;
            margin-top: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Christopher and Raymond's Musical Guestbook</h1>

    <!-- Staff Area (canvas with treble clef and overlaid title input) -->
    <div id="staffContainer">
        <!-- Song Title input overlaid on the staff -->
        <input type="text" id="submitTitle" placeholder="Enter a song title">
        <!-- Treble clef image -->
        <img id="trebleClef" src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='45' height='100'><text x='0' y='70' font-size='80'>ùÑû</text></svg>" alt="Treble Clef">
        <canvas id="staffCanvas" width="1200" height="200"></canvas>
    </div>

    <!-- Controls Row -->
    <div id="controlsRow">
        <div id="instrumentSelectContainer">
            <label for="instrumentSelect">Instrument: </label>
            <select id="instrumentSelect">
                <option value="sine">Sine</option>
                <option value="square">Square</option>
                <option value="sawtooth">Sawtooth</option>
                <option value="triangle">Triangle</option>
            </select>
        </div>
        <div id="playControls">
            <label>Song Controls:</label>
            <button id="playButton">&#9658;</button>
            <button id="stopButton">&#9632;</button>
            <button id="clearButton">Clear</button>
        </div>
        <div id="noteControls">
            <label>Note Controls:</label>
            <button id="sharpButton">‚ôØ</button>
            <button id="flatButton">‚ô≠</button>
            <button id="naturalButton">‚ôÆ</button>
            <button id="deleteButton">Delete</button>
            <button id="holdLongerButton">Hold Longer</button>
            <button id="holdShorterButton">Hold Shorter</button>
        </div>
    </div>

    <!-- Submission Form: only Name and Comment, with Submit at the bottom -->
    <div id="submissionFormContainer">
        <h2>Sign Here</h2>
        <form id="submissionForm">
            <input type="text" id="submitName" placeholder="Guest name(s) *" required>
            <textarea id="submitComment" placeholder="Leave a message!"></textarea>
            <button type="submit">Submit</button>
        </form>
        <div id="submissionError"></div>
    </div>

    <!-- Submissions Table with pagination -->
    <div id="submissionsTableContainer">
        <h2>Submitted Compositions</h2>
        <table id="submissionsTable">
            <thead>
            <tr>
                <th>Guest name(s)</th>
                <th>Song title</th>
                <th>Comment</th>
                <th>Action</th>
            </tr>
            </thead>
            <tbody>
            <!-- Submissions will be populated here via web calls -->
            </tbody>
        </table>
        <div id="paginationControls">
            <button id="prevPage">Previous</button>
            <span id="currentPage">Page 1</span>
            <button id="nextPage">Next</button>
        </div>
    </div>

</div>

<script>
    /***** Global Variables & Constants *****/
    const NUM_BEATS = 17; // Beat 0 for notation only; 1-17 for music
    const measureDivisions = [0, 1, 5, 9, 13, 17];
    const pitchMidi = [null, 60, 62, 64, 65, 67, 69, 71, 72, 74, 76, 77, 79, 81, 83, 84];
    let staffNotes = new Array(NUM_BEATS).fill(null);
    let selectedBeat = -1;
    let currentAccidental = "natural";
    let currentInstrument = "sine";

    const canvas = document.getElementById("staffCanvas");
    const ctx = canvas.getContext("2d");
    const STAFF_LEFT = 100;
    const STAFF_RIGHT = canvas.width - 100;
    const STAFF_WIDTH = STAFF_RIGHT - STAFF_LEFT;
    const BEAT_WIDTH = STAFF_WIDTH / NUM_BEATS;
    const staffLinePitches = [3, 5, 7, 9, 11];
    const NUM_PITCHES = 15;
    const noteSpacing = 10;
    const totalStaffHeight = (NUM_PITCHES - 1) * noteSpacing;
    const STAFF_TOP = (canvas.height - totalStaffHeight) / 2;
    const NOTE_RADIUS = 9;

    let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let isDragging = false;
    let dragBeat = null;
    let playTimeouts = [];
    let isPlaying = false;

    // Pagination variables
    let currentPage = 0;
    const PAGE_SIZE = 20;

    /***** Utility Functions *****/
    function yForPitch(pitchIndex) {
        return STAFF_TOP + (NUM_PITCHES - pitchIndex) * noteSpacing;
    }

    function beatForX(x) {
        let b = Math.floor((x - STAFF_LEFT) / BEAT_WIDTH);
        return Math.max(0, Math.min(NUM_BEATS - 1, b));
    }

    function pitchForY(y) {
        let approx = NUM_PITCHES - ((y - STAFF_TOP) / noteSpacing);
        let p = Math.round(approx);
        return Math.max(1, Math.min(NUM_PITCHES, p));
    }

    function getCanvasPos(e) {
        let rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function getChainIndices(beat) {
        if (!staffNotes[beat]) return [];
        // Walk backward to find the start (a note that isn‚Äôt tied)
        let start = beat;
        while (start > 1 && staffNotes[start] && staffNotes[start].tied) {
            start--;
        }
        // Now collect the chain (the first note plus any consecutive tied notes)
        let indices = [];
        let i = start;
        while (i < NUM_BEATS && staffNotes[i]) {
            indices.push(i);
            if (i === NUM_BEATS - 1) break;
            if (!staffNotes[i + 1] || !staffNotes[i + 1].tied) break;
            i++;
        }
        return indices;
    }

    /***** Audio Playback *****/
    function playTone(note, isPreview = false, durationOverride = null) {
        if (!note) return;
        const tempo = 120;
        const beatDuration = 60 / tempo;
        const duration = isPreview ? 0.1 : (durationOverride !== null ? durationOverride : (beatDuration * 0.9));
        let midi = pitchMidi[note.pitch];
        if (note.accidental === "sharp") midi += 1;
        if (note.accidental === "flat") midi -= 1;
        let freq = 440 * Math.pow(2, (midi - 69) / 12);
        let osc = audioCtx.createOscillator();
        let gainNode = audioCtx.createGain();
        osc.type = currentInstrument;
        osc.frequency.value = freq;
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        let now = audioCtx.currentTime;
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
        osc.start(now);
        osc.stop(now + duration);
    }

    function drawStaff() {
        const gap = 5;
        const extendedStaffEnd = STAFF_RIGHT + gap + 3;
        const thickBarX = STAFF_RIGHT + gap;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        staffLinePitches.forEach(pitchIndex => {
            let y = yForPitch(pitchIndex);
            ctx.beginPath();
            ctx.moveTo(STAFF_LEFT, y);
            ctx.lineTo(extendedStaffEnd, y);
            ctx.stroke();
        });

        // Draw vertical measure lines.
        let topLineY = yForPitch(11);
        let botLineY = yForPitch(3);
        measureDivisions.forEach(div => {
            if (div === 1) return;
            let x = STAFF_LEFT + div * BEAT_WIDTH;
            ctx.beginPath();
            ctx.moveTo(x, topLineY);
            ctx.lineTo(x, botLineY);
            ctx.stroke();
        });

        // Draw notes (or rests for beats 2+)
        for (let b = 0; b < NUM_BEATS; b++) {
            if (staffNotes[b]) {
                drawNote(staffNotes[b], b, (b === selectedBeat));
            } else if (b > 0) {
                drawRest(b);
            }
        }

        ctx.save();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(thickBarX, topLineY);
        ctx.lineTo(thickBarX, botLineY);
        ctx.stroke();
        ctx.restore();
    }

    function drawRest(beat) {
        const REST_OFFSET = 10;
        let xCenter = STAFF_LEFT + (beat + 0.5) * BEAT_WIDTH + REST_OFFSET;
        let yCenter = yForPitch(7);
        ctx.save();
        ctx.fillStyle = "#000";
        ctx.font = "60px italic serif";
        ctx.fillText("ùÑΩ", xCenter - 24, yCenter + 18);
        ctx.restore();
    }

    // Draw ledger lines for notes outside the staff range
    function drawLedgerLines(note, x, radius) {
        ctx.save();
        ctx.strokeStyle = "#000";
        if (note.pitch < 3) {
            for (let p = 1; p >= note.pitch; p -= 2) {
                let ly = yForPitch(p);
                ctx.beginPath();
                ctx.moveTo(x - radius - 4, ly);
                ctx.lineTo(x + radius + 4, ly);
                ctx.stroke();
            }
        }
        if (note.pitch > 11) {
            for (let p = 13; p <= note.pitch; p += 2) {
                let ly = yForPitch(p);
                ctx.beginPath();
                ctx.moveTo(x - radius - 4, ly);
                ctx.lineTo(x + radius + 4, ly);
                ctx.stroke();
            }
        }
        ctx.restore();
    }

    // Draw a quarter note with stem and accidental styling
    function drawNote(note, beat, isSelected) {
        let xCenter = STAFF_LEFT + (beat + 0.5) * BEAT_WIDTH;
        let yCenter = yForPitch(note.pitch);

        if (isSelected) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 150, 255, 0.3)";
            ctx.beginPath();
            ctx.arc(xCenter, yCenter, NOTE_RADIUS + 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        drawLedgerLines(note, xCenter, NOTE_RADIUS);

        ctx.save();
        ctx.beginPath();
        ctx.ellipse(xCenter, yCenter, NOTE_RADIUS, NOTE_RADIUS + 3, 1, 0, 2 * Math.PI);
        ctx.fill();

        const stemLength = 55;
        ctx.beginPath();
        if (note.pitch >= 7) {
            ctx.moveTo(xCenter - NOTE_RADIUS - 2, yCenter);
            ctx.lineTo(xCenter - NOTE_RADIUS - 2, yCenter + stemLength);
        } else {
            ctx.moveTo(xCenter + NOTE_RADIUS + 2, yCenter);
            ctx.lineTo(xCenter + NOTE_RADIUS + 2, yCenter - stemLength);
        }
        ctx.stroke();

        if (note.accidental && note.accidental !== "natural") {
            ctx.font = "32px italic serif";
            ctx.fillStyle = "#000";
            let symbol;
            let yAdd;
            if (note.accidental === "sharp") {
                yAdd = 11;
                symbol = "#";
            } else {
                yAdd = 5
                symbol = "‚ô≠";
            }
            ctx.fillText(symbol, xCenter - (NOTE_RADIUS + 19), yCenter + yAdd);
        }

        if (
            note.tied &&
            beat > 0 &&
            staffNotes[beat - 1] &&
            staffNotes[beat - 1].pitch === note.pitch &&
            staffNotes[beat - 1].accidental === note.accidental
        ) {
            // Get centers for the previous and current notes.
            let prevNote = staffNotes[beat - 1];
            let xPrevCenter = STAFF_LEFT + (beat - 0.5) * BEAT_WIDTH;
            let xCurrCenter = STAFF_LEFT + (beat + 0.5) * BEAT_WIDTH;
            let yPrevCenter = yForPitch(prevNote.pitch);
            let yCurrCenter = yForPitch(note.pitch);

            // Determine tie direction: for higher notes, draw the tie above; for lower, below.
            let tieDirection = (note.pitch >= 7) ? "up" : "down";
            let offset = 2; // extra separation from the note head edge

            // Calculate attachment points based on tie direction.
            let y1 =
                tieDirection === "up"
                    ? yPrevCenter - (NOTE_RADIUS + offset)
                    : yPrevCenter + (NOTE_RADIUS + offset);
            let y2 =
                tieDirection === "up"
                    ? yCurrCenter - (NOTE_RADIUS + offset)
                    : yCurrCenter + (NOTE_RADIUS + offset);
            let x1 = xPrevCenter;
            let x2 = xCurrCenter;

            // Control point for the curve.
            let cpX = (x1 + x2) / 2;
            let arcHeight = 25;
            let cpY =
                tieDirection === "up"
                    ? Math.min(y1, y2) - arcHeight
                    : Math.max(y1, y2) + arcHeight;

            // Thickness in the middle of the tie.
            let tieThickness = 8;

            ctx.save();
            ctx.fillStyle = "#000";
            ctx.beginPath();
            // Draw the primary edge of the tie.
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo(cpX, cpY, x2, y2);
            // Draw the opposite edge, offset by tieThickness.
            if (tieDirection === "up") {
                ctx.quadraticCurveTo(cpX, cpY + tieThickness, x1, y1);
            } else {
                ctx.quadraticCurveTo(cpX, cpY - tieThickness, x1, y1);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        ctx.restore();
    }

    /***** Event Handling: Pointer Down/Move/Up *****/
    canvas.addEventListener("mousedown", pointerDown);
    canvas.addEventListener("touchstart", pointerDown);
    function pointerDown(e) {
        e.preventDefault();
        let pos = getCanvasPos(e);
        let beat = beatForX(pos.x);
        if (beat < 1) return; // Ignore notation-only area

        if (staffNotes[beat]) {
            // There is already a note at this beat.
            // Compute its center (using its pitch) to see if we clicked directly on it.
            let note = staffNotes[beat];
            let xCenter = STAFF_LEFT + (beat + 0.5) * BEAT_WIDTH;
            let yCenter = yForPitch(note.pitch);
            let dx = pos.x - xCenter;
            let dy = pos.y - yCenter;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let threshold = NOTE_RADIUS + 5; // Adjust this value as needed

            if (distance <= threshold) {
                // Tapped directly on the note head:
                let chainIndices = getChainIndices(beat);
                selectedBeat = chainIndices[0];
                dragBeat = selectedBeat;
                drawStaff();
                playTone(note, false);
            } else {
                // Clicked away from the center of the note head:
                // Update the entire chain to the new pitch (and clear accidentals)
                let newPitch = pitchForY(pos.y);
                let chainIndices = getChainIndices(beat);
                chainIndices.forEach(i => {
                    staffNotes[i].pitch = newPitch;
                    staffNotes[i].accidental = "natural";
                });
                selectedBeat = chainIndices[0];
                dragBeat = selectedBeat;
                drawStaff();
                playTone(staffNotes[chainIndices[0]], false);
            }
        } else {
            // No note exists at this beat: create a new note using currentAccidental.
            let pitch = pitchForY(pos.y);
            staffNotes[beat] = { pitch, accidental: currentAccidental };
            selectedBeat = beat;
            dragBeat = beat;
            drawStaff();
            playTone(staffNotes[beat], false);
        }
        isDragging = true;
    }
    canvas.addEventListener("mousemove", pointerMove);
    canvas.addEventListener("touchmove", pointerMove);
    function pointerMove(e) {
        if (!isDragging || dragBeat === null) return;
        e.preventDefault();
        let pos = getCanvasPos(e);
        let newPitch = pitchForY(pos.y);

        let chainIndices = getChainIndices(dragBeat);
        if (chainIndices.length === 0) return;

        // Only update if the pitch has actually changed from the chain's starting note.
        let currentPitch = staffNotes[chainIndices[0]].pitch;
        if (newPitch !== currentPitch) {
            chainIndices.forEach(i => {
                staffNotes[i].pitch = newPitch;
                staffNotes[i].accidental = "natural"; // clear accidental when dragging
            });
            playTone(staffNotes[chainIndices[0]], true);
            drawStaff();
        }
    }
    canvas.addEventListener("mouseup", pointerUp);
    canvas.addEventListener("touchend", pointerUp);
    function pointerUp(e) {
        if (isDragging) {
            isDragging = false;
            dragBeat = null;
        }
    }
    window.addEventListener("keydown", e => {
        if (selectedBeat < 1 || selectedBeat === -1) return;
        let chainIndices = getChainIndices(selectedBeat);
        switch (e.key) {
            case "ArrowUp":
                chainIndices.forEach(i => {
                    staffNotes[i].pitch = Math.min(15, staffNotes[i].pitch + 1);
                    staffNotes[i].accidental = "natural"; // reset accidental when moving
                });
                playTone(staffNotes[chainIndices[0]]);
                drawStaff();
                break;
            case "ArrowDown":
                chainIndices.forEach(i => {
                    staffNotes[i].pitch = Math.max(1, staffNotes[i].pitch - 1);
                    staffNotes[i].accidental = "natural"; // reset accidental when moving
                });
                playTone(staffNotes[chainIndices[0]]);
                drawStaff();
                break;
            case "ArrowLeft":
                for (let b = selectedBeat - 1; b >= 2; b--) {
                    if (staffNotes[b]) {
                        selectedBeat = b;
                        playTone(staffNotes[b], true);
                        drawStaff();
                        break;
                    }
                }
                break;
            case "ArrowRight":
                for (let b = selectedBeat + 1; b < NUM_BEATS; b++) {
                    if (staffNotes[b]) {
                        selectedBeat = b;
                        playTone(staffNotes[b], true);
                        drawStaff();
                        break;
                    }
                }
                break;
        }
    });

    /***** Playback Controls *****/
    function stopPlayback() {
        playTimeouts.forEach(id => clearTimeout(id));
        playTimeouts = [];
        isPlaying = false;
    }
    function playStaff() {
        stopPlayback();
        isPlaying = true;
        const tempo = 120;
        const beatDuration = 60 / tempo;
        let b = 1;
        while(b < NUM_BEATS) {
            if (staffNotes[b] && !staffNotes[b].tied) {
                let note = staffNotes[b];
                let chainLength = 1;
                while(b + chainLength < NUM_BEATS &&
                staffNotes[b + chainLength] &&
                staffNotes[b + chainLength].tied &&
                staffNotes[b + chainLength].pitch === note.pitch &&
                staffNotes[b + chainLength].accidental === note.accidental) {
                    chainLength++;
                }
                let duration = beatDuration * 0.9 * chainLength;
                let timeoutId = setTimeout(() => {
                    playTone(note, false, duration);
                }, (b - 1) * beatDuration * 1000);
                playTimeouts.push(timeoutId);
                b += chainLength;
                continue;
            }
            b++;
        }
    }
    document.getElementById("instrumentSelect").addEventListener("change", (e) => {
        currentInstrument = e.target.value;
    });
    document.getElementById("playButton").addEventListener("click", playStaff);
    document.getElementById("stopButton").addEventListener("click", stopPlayback);

    /***** Note Control Functionality *****/
    document.getElementById("sharpButton").addEventListener("click", () => {
        if (selectedBeat >= 2 && staffNotes[selectedBeat]) {
            let chainIndices = getChainIndices(selectedBeat);
            chainIndices.forEach(i => {
                staffNotes[i].accidental = "sharp";
            });
            drawStaff();
        }
    });
    document.getElementById("flatButton").addEventListener("click", () => {
        if (selectedBeat >= 2 && staffNotes[selectedBeat]) {
            let chainIndices = getChainIndices(selectedBeat);
            chainIndices.forEach(i => {
                staffNotes[i].accidental = "flat";
            });
            drawStaff();
        }
    });
    document.getElementById("naturalButton").addEventListener("click", () => {
        if (selectedBeat >= 2 && staffNotes[selectedBeat]) {
            let chainIndices = getChainIndices(selectedBeat);
            chainIndices.forEach(i => {
                staffNotes[i].accidental = "natural";
            });
            drawStaff();
        }
    });
    document.getElementById("deleteButton").addEventListener("click", () => {
        if (selectedBeat >= 2 && staffNotes[selectedBeat]) {
            let chainIndices = getChainIndices(selectedBeat);
            chainIndices.forEach(i => {
                staffNotes[i] = null;
            });
            selectedBeat = -1;
            drawStaff();
        }
    });
    function holdLonger() {
        if (selectedBeat < 1 || !staffNotes[selectedBeat]) {
            alert("Select a note to hold.");
            return;
        }
        let chainIndices = getChainIndices(selectedBeat);
        let lastIndex = chainIndices[chainIndices.length - 1];
        if (lastIndex >= NUM_BEATS - 1) {
            alert("Cannot extend beyond the last beat.");
            return;
        }
        let baseNote = staffNotes[lastIndex];
        staffNotes[lastIndex + 1] = {
            pitch: baseNote.pitch,
            accidental: baseNote.accidental,
            tied: true
        };
        selectedBeat = lastIndex + 1;
        drawStaff();
        playTone(staffNotes[selectedBeat], true);
    }
    document.getElementById("holdLongerButton").addEventListener("click", holdLonger);
    function holdShorter() {
        if (selectedBeat < 1 || !staffNotes[selectedBeat]) {
            alert("No note selected to shorten.");
            return;
        }
        let chainIndices = getChainIndices(selectedBeat);
        if (chainIndices.length === 1) {
            alert("No held note to shorten.");
        } else {
            let lastIndex = chainIndices[chainIndices.length - 1];
            staffNotes[lastIndex] = null;
            // Optionally update selectedBeat to the new end of the chain.
            selectedBeat = chainIndices[chainIndices.length - 2];
            drawStaff();
        }
    }
    document.getElementById("holdShorterButton").addEventListener("click", holdShorter);

    /***** Clear Button *****/
    document.getElementById("clearButton").addEventListener("click", () => {
        if (staffNotes.slice(2).some(n => n !== null) &&
            !confirm("This will clear your current composition. Continue?")) {
            return;
        }
        staffNotes = new Array(NUM_BEATS).fill(null);
        selectedBeat = -1;
        drawStaff();
    });

    /***** Submission Handling & Pagination *****/
    const submissionForm = document.getElementById("submissionForm");
    const submissionErrorDiv = document.getElementById("submissionError");
    const submissionsTableBody = document.querySelector("#submissionsTable tbody");
    const currentPageSpan = document.getElementById("currentPage");

    // Fetch submissions with pagination. (Ensure your backend supports Pageable.)
    function fetchSubmissions() {
        fetch(`/api/submissions?page=${currentPage}&size=${PAGE_SIZE}`)
            .then(response => response.json())
            .then(data => {
                updateSubmissionsTable(data.content);
                currentPageSpan.textContent = `Page ${currentPage + 1}`;

                document.getElementById("nextPage").disabled = currentPage >= data.page.totalPages - 1;
                document.getElementById("prevPage").disabled = currentPage <= 0;
            })
            .catch(error => {
                console.error("Error fetching submissions:", error);
            });
    }

    // Update the submissions table
    function updateSubmissionsTable(submissions) {
        submissionsTableBody.innerHTML = "";
        submissions.forEach(sub => {
            submissionsTableBody.appendChild(createSubmissionRow(sub));
        });
    }

    // Create a table row for a submission
    function createSubmissionRow(submission) {
        let tr = document.createElement("tr");

        let tdName = document.createElement("td");
        tdName.textContent = submission.name;

        let tdTitle = document.createElement("td");
        tdTitle.textContent = submission.title;

        let tdComment = document.createElement("td");
        tdComment.textContent = submission.comment;

        let tdActions = document.createElement("td");
        let playBtn = document.createElement("button");
        playBtn.textContent = "Play";
        playBtn.addEventListener("click", () => playSubmission(submission));
        let loadBtn = document.createElement("button");
        loadBtn.textContent = "Load";
        loadBtn.addEventListener("click", () => loadSubmission(submission));

        tdActions.appendChild(playBtn);
        tdActions.appendChild(loadBtn);
        tr.appendChild(tdName);
        tr.appendChild(tdTitle);
        tr.appendChild(tdComment);
        tr.appendChild(tdActions);

        return tr;
    }

    // Play a submission‚Äôs song
    function playSubmission(submission) {
        let song;
        try {
            song = JSON.parse(submission.song);
        } catch (err) {
            return alert("Invalid song data in submission.");
        }
        stopPlayback();
        const tempo = 120;
        const beatDuration = 60 / tempo;
        let b = 1;
        while (b < song.length) {
            if (song[b] && !song[b].tied) {
                let note = song[b];
                let chainLength = 1;
                while (b + chainLength < song.length &&
                song[b + chainLength] &&
                song[b + chainLength].tied &&
                song[b + chainLength].pitch === note.pitch &&
                song[b + chainLength].accidental === note.accidental) {
                    chainLength++;
                }
                let duration = beatDuration * 0.9 * chainLength;
                let timeoutId = setTimeout(() => {
                    playTone(note, false, duration);
                }, (b - 1) * beatDuration * 1000);
                playTimeouts.push(timeoutId);
                b += chainLength;
                continue;
            }
            b++;
        }
        isPlaying = true;
    }

    // Load a submission‚Äôs song into the work area
    function loadSubmission(submission) {
        if (staffNotes.slice(2).some(n => n !== null) &&
            !confirm("This will clear your current composition. Continue?")) {
            return;
        }
        let song;
        try {
            song = JSON.parse(submission.song);
        } catch (err) {
            return alert("Invalid song data in submission.");
        }
        staffNotes = new Array(NUM_BEATS).fill(null);
        for (let b = 0; b < NUM_BEATS; b++) {
            if (song[b]) {
                staffNotes[b] = { ...song[b] };
            }
        }
        if (submission.instrument) {
            currentInstrument = submission.instrument;
            document.getElementById("instrumentSelect").value = currentInstrument;
        }
        selectedBeat = -1;
        drawStaff();
    }

    // Submission Form: Only name is required; if title, comment, or composition are missing, show a confirm alert.
    submissionForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const name = document.getElementById("submitName").value.trim();
        const title = document.getElementById("submitTitle").value.trim();
        const comment = document.getElementById("submitComment").value.trim();

        if (!name) {
            alert("Guest name is required.");
            return;
        }

        let missingFields = [];
        if (!title) missingFields.push("song title");
        if (!comment) missingFields.push("message");
        let compositionEmpty = staffNotes.slice(2).every(n => n === null);
        if (compositionEmpty) missingFields.push("composition");

        if (missingFields.length > 0) {
            if (!confirm("The following fields are missing: " + missingFields.join(", ") + ". Do you want to proceed?")) {
                return;
            }
        }

        const submissionData = {
            name: name,
            title: title,
            song: JSON.stringify(staffNotes),
            comment: comment,
            instrument: currentInstrument
        };

        fetch("/api/submissions/" + encodeURIComponent(name), {
            method: "PUT",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(submissionData)
        })
            .then(response => {
                if (!response.ok) {
                    if (response.status === 409) {
                        throw new Error("A submission with this guest name already exists. Please choose a unique name.");
                    } else {
                        throw new Error("Error submitting composition.");
                    }
                }
                return response.json();
            })
            .then(data => {
                submissionErrorDiv.textContent = "";
                submissionForm.reset();
                // Clear the composition if necessary.
                if (staffNotes.slice(2).some(n => n !== null)) {
                    staffNotes = new Array(NUM_BEATS).fill(null);
                    selectedBeat = -1;
                    drawStaff();
                }
                // Refresh the submissions table (pagination will update automatically)
                fetchSubmissions();
            })
            .catch(error => {
                submissionErrorDiv.textContent = error.message;
            });
    });

    // Pagination Controls
    document.getElementById("prevPage").addEventListener("click", () => {
        if (currentPage > 0) {
            currentPage--;
            fetchSubmissions();
        }
    });
    document.getElementById("nextPage").addEventListener("click", () => {
        currentPage++;
        fetchSubmissions();
    });

    // Initial fetch and draw
    fetchSubmissions();
    drawStaff();
</script>
</body>
</html>
