<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Christopher and Raymond's Musical Guestbook</title>
    <link href="./css2.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3da5d9; /* Bright blue */
            --secondary-color: #6c4675; /* Purple */
            --accent-color: #36b5a2; /* Aquamarine */
            --light-color: #e0f7fa; /* Very light aqua */
            --dark-color: #2c3e50; /* Dark slate */
            --gradient: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            --card-width: 80%; /* Standardized card width */
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background: linear-gradient(135deg, #f0f8ff, #e0f7fa);
            margin: 0;
            padding: 0;
            color: var(--dark-color);
        }

        .container {
            width: 85%;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(108, 70, 117, 0.3);
        }

        h1, h2, h3 {
            font-family: 'Playfair Display', serif;
            color: var(--secondary-color);
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        h2 {
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }

        /* Card styling for consistent appearance */
        .card {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin: 1.5rem auto;
            padding: 1.5rem;
            width: var(--card-width);
        }

        /* Staff Area */
        #staffContainer {
            position: relative;
            text-align: center;
        }

        #staffCanvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            touch-action: none;
            margin: 0 auto;
            display: block;
            max-width: 100%;
        }

        #trebleClef {
            position: absolute;
            left: 156px;
            top: 167px;
            height: 90px;
            opacity: 0.8;
            pointer-events: none;
        }

        #submitTitle {
            display: block;
            margin: 0.5rem auto 1rem;
            font-size: 1.3rem;
            padding: 0.6rem 1rem;
            width: 60%;
            text-align: center;
            border: 2px solid rgba(54, 181, 162, 0.3);
            border-radius: 30px;
            background-color: white;
            font-family: 'Playfair Display', serif;
            color: var(--secondary-color);
            transition: all 0.3s ease;
        }

        #submitTitle:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(54, 181, 162, 0.2);
        }

        /* Controls & Buttons */
        #controlsCard {
            padding-bottom: 0.5rem;
        }

        #controlsRow {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .control-section {
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        #playControls, #noteControls {
            display: flex;
            align-items: center;
            gap: 0.8rem;
            justify-content: center;
        }

        button {
            background: var(--gradient);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 0.6rem 1.2rem;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Montserrat', sans-serif;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            height: 42px; /* Standardized height */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
        }

        #playButton, #stopButton, #clearButton {
            width: 42px;
            font-size: 1.2rem;
        }

        #playButton {
            background: linear-gradient(135deg, var(--accent-color), #2e9c8c);
        }

        #stopButton {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        #clearButton {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            width: auto;
        }

        /* Accidental buttons need same height */
        #sharpButton, #flatButton, #naturalButton,
        #deleteButton, #holdLongerButton, #holdShorterButton {
            height: 42px;
            font-size: 1.3rem;
            font-weight: bold;
        }

        #sharpButton, #flatButton, #naturalButton {
            background: linear-gradient(135deg, var(--secondary-color), #553360);
            width: 42px;
        }

        #deleteButton {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        #holdLongerButton, #holdShorterButton {
            background: linear-gradient(135deg, #f39c12, #d35400);
        }

        label {
            color: var(--dark-color);
            font-weight: 500;
            margin-right: 0.5rem;
        }

        select {
            padding: 0.5rem;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-family: 'Montserrat', sans-serif;
            background-color: white;
            height: 42px;
        }

        /* Submission Form */
        #submissionForm {
            display: flex;
            flex-direction: column;
            gap: 1.2rem;
            align-items: center;
        }

        #submitName, #submitComment {
            width: 80%;
            padding: 0.8rem 1rem;
            border: 2px solid rgba(61, 165, 217, 0.3);
            border-radius: 8px;
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        #submitName:focus, #submitComment:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(61, 165, 217, 0.2);
        }

        #submitComment {
            min-height: 100px;
            resize: vertical;
        }

        #submissionForm button {
            margin-top: 1rem;
            padding: 0.8rem 2rem;
            font-size: 1.1rem;
            font-weight: 500;
            background: linear-gradient(135deg, var(--secondary-color), #553360);
            border-radius: 30px;
            width: 40%;
            height: auto;
        }

        #submissionError {
            color: #e74c3c;
            margin-top: 1rem;
            text-align: center;
            font-weight: 500;
        }

        /* Submissions Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            border-radius: 8px;
            overflow: hidden;
        }

        thead {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            color: white;
        }

        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        th:nth-child(1), td:nth-child(1) {
            width: 18%;
        }

        th:nth-child(2), td:nth-child(2) {
            width: 18%;
        }

        th:nth-child(3), td:nth-child(3) {
            width: 50%;
        }

        th:nth-child(4), td:nth-child(4) {
            width: 18%;
            text-align: center;
        }

        td:nth-child(4) button {
            display: inline-block;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        tr:hover {
            background-color: var(--light-color);
        }

        td button {
            margin: 0.3rem;
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
            height: 36px;
        }

        /* Pagination Controls */
        #paginationControls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1.5rem;
            gap: 1rem;
        }

        #currentPage {
            font-weight: 500;
            color: var(--dark-color);
            padding: 0.5rem 1rem;
            background: var(--light-color);
            border-radius: 5px;
        }

        #prevPage, #nextPage {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            padding: 0.5rem 1rem;
        }

        /* Wedding theme decorative elements */
        .wedding-decoration {
            position: absolute;
            width: 180px;
            height: 180px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath fill='%233da5d9' opacity='0.2' d='M50 0C22.4 0 0 22.4 0 50s22.4 50 50 50 50-22.4 50-50S77.6 0 50 0zm0 90c-22.1 0-40-17.9-40-40s17.9-40 40-40 40 17.9 40 40-17.9 40-40 40z'/%3E%3C/svg%3E");
            opacity: 0.3;
            z-index: -1;
        }

        .decoration-1 {
            top: 20px;
            left: 20px;
            transform: rotate(-15deg);
        }

        .decoration-2 {
            bottom: 20px;
            right: 20px;
            transform: rotate(15deg);
        }

        footer {
            text-align: center;
            margin-top: 3rem;
            padding: 1rem;
            color: var(--dark-color);
            opacity: 0.7;
            font-size: 0.9rem;
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .container {
                width: 95%;
            }

            .card {
                width: 95%;
            }
        }

        @media (max-width: 768px) {
            #playControls, #noteControls {
                flex-wrap: wrap;
                justify-content: center;
            }

            th, td {
                padding: 0.7rem 0.5rem;
                font-size: 0.9rem;
            }

            #submitTitle, #submitName, #submitComment {
                width: 90%;
            }

            #submissionForm button {
                width: 60%;
            }
        }
    </style>
</head>
<body>
<div class="wedding-decoration decoration-1"></div>
<div class="wedding-decoration decoration-2"></div>

<div class="container">
    <header>
        <h1>Christopher & Raymond's Musical Guestbook</h1>
        <p>Share your melodic wishes for our special day</p>
    </header>

    <!-- Staff Area with title input -->
    <div id="staffContainer" class="card">
        <input type="text" id="submitTitle" placeholder="Your Song Title">
        <img id="trebleClef" src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='45' height='100'><text x='0' y='70' font-size='80'>ùÑû</text></svg>" alt="Treble Clef">
        <canvas id="staffCanvas" width="1000" height="200"></canvas>
    </div>

    <!-- Controls Card with two sections -->
    <div id="controlsCard" class="card">
        <div id="controlsRow">
            <div class="control-section">
                <div id="playControls">
                    <label>Play Controls:</label>
                    <div id="instrumentSelectContainer">
                        <label for="instrumentSelect">Instrument: </label>
                        <select id="instrumentSelect">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="sawtooth">Sawtooth</option>
                            <option value="triangle">Triangle</option>
                        </select>
                    </div>
                    <button id="playButton">‚ñ∂</button>
                    <button id="stopButton">‚óº</button>
                    <button id="clearButton">Clear</button>
                </div>
            </div>
            <div class="control-section">
                <div id="noteControls">
                    <label>Note Controls:</label>
                    <button id="sharpButton">‚ôØ</button>
                    <button id="flatButton">‚ô≠</button>
                    <button id="naturalButton">‚ôÆ</button>
                    <button id="deleteButton">Delete</button>
                    <button id="holdLongerButton">Hold +</button>
                    <button id="holdShorterButton">Hold -</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Submission Form -->
    <div id="submissionFormContainer" class="card">
        <h2>Sign Our Musical Guestbook</h2>
        <form id="submissionForm">
            <input type="text" id="submitName" placeholder="Your Name(s) *" required>
            <textarea id="submitComment" placeholder="Leave a message for the happy couple!"></textarea>
            <button type="submit">Sign Guestbook</button>
        </form>
        <div id="submissionError"></div>
    </div>

    <!-- Submissions Table -->
    <div id="submissionsTableContainer" class="card">
        <h2>Messages from Guests</h2>
        <table id="submissionsTable">
            <thead>
            <tr>
                <th>Guest Name(s)</th>
                <th>Song Title</th>
                <th>Message</th>
                <th>Actions</th>
            </tr>
            </thead>
            <tbody>
            <!-- Submissions will be populated here via web calls -->
            </tbody>
        </table>
        <div id="paginationControls">
            <button id="prevPage">Previous</button>
            <span id="currentPage">Page 1</span>
            <button id="nextPage">Next</button>
        </div>
    </div>

    <footer>
        <p>Christopher & Raymond's Wedding Celebration | March 1, 2025</p>
    </footer>
</div>

<script>
    /***** Global Variables & Constants *****/
    const NUM_BEATS = 17; // Beat 0 for notation only; 1-17 for music
    const measureDivisions = [0, 1, 5, 9, 13, 17];
    const pitchMidi = [null, 60, 62, 64, 65, 67, 69, 71, 72, 74, 76, 77, 79, 81, 83, 84];
    let staffNotes = new Array(NUM_BEATS).fill(null);
    let selectedBeat = -1;
    let currentAccidental = "natural";
    let currentInstrument = "sine";

    const canvas = document.getElementById("staffCanvas");
    const ctx = canvas.getContext("2d");
    const STAFF_LEFT = 50;
    const STAFF_RIGHT = canvas.width - 50;
    const STAFF_WIDTH = STAFF_RIGHT - STAFF_LEFT;
    const BEAT_WIDTH = STAFF_WIDTH / NUM_BEATS;
    const staffLinePitches = [3, 5, 7, 9, 11];
    const NUM_PITCHES = 15;
    const noteSpacing = 10;
    const totalStaffHeight = (NUM_PITCHES - 1) * noteSpacing;
    const STAFF_TOP = (canvas.height - totalStaffHeight) / 2;
    const NOTE_RADIUS = 9;

    let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let isDragging = false;
    let dragBeat = null;
    let playTimeouts = [];
    let isPlaying = false;

    // Pagination variables
    let currentPage = 0;
    const PAGE_SIZE = 20;

    /***** Utility Functions *****/
    function yForPitch(pitchIndex) {
        return STAFF_TOP + (NUM_PITCHES - pitchIndex) * noteSpacing;
    }

    function beatForX(x) {
        let b = Math.floor((x - STAFF_LEFT) / BEAT_WIDTH);
        return Math.max(0, Math.min(NUM_BEATS - 1, b));
    }

    function pitchForY(y) {
        let approx = NUM_PITCHES - ((y - STAFF_TOP) / noteSpacing);
        let p = Math.round(approx);
        return Math.max(1, Math.min(NUM_PITCHES, p));
    }

    function getCanvasPos(e) {
        let rect = canvas.getBoundingClientRect();
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function getChainIndices(beat) {
        if (!staffNotes[beat]) return [];
        // Walk backward to find the start (a note that isn‚Äôt tied)
        let start = beat;
        while (start > 1 && staffNotes[start] && staffNotes[start].tied) {
            start--;
        }
        // Now collect the chain (the first note plus any consecutive tied notes)
        let indices = [];
        let i = start;
        while (i < NUM_BEATS && staffNotes[i]) {
            indices.push(i);
            if (i === NUM_BEATS - 1) break;
            if (!staffNotes[i + 1] || !staffNotes[i + 1].tied) break;
            i++;
        }
        return indices;
    }

    /***** Audio Playback *****/
    function playTone(note, isPreview = false, durationOverride = null) {
        if (!note) return;
        const tempo = 120;
        const beatDuration = 60 / tempo;
        const duration = isPreview ? 0.1 : (durationOverride !== null ? durationOverride : (beatDuration * 0.9));
        let midi = pitchMidi[note.pitch];
        if (note.accidental === "sharp") midi += 1;
        if (note.accidental === "flat") midi -= 1;
        let freq = 440 * Math.pow(2, (midi - 69) / 12);
        let osc = audioCtx.createOscillator();
        let gainNode = audioCtx.createGain();
        osc.type = currentInstrument;
        osc.frequency.value = freq;
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        let now = audioCtx.currentTime;
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
        osc.start(now);
        osc.stop(now + duration);
    }

    function drawStaff() {
        const gap = 5;
        const extendedStaffEnd = STAFF_RIGHT + gap + 3;
        const thickBarX = STAFF_RIGHT + gap;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        staffLinePitches.forEach(pitchIndex => {
            let y = yForPitch(pitchIndex);
            ctx.beginPath();
            ctx.moveTo(STAFF_LEFT, y);
            ctx.lineTo(extendedStaffEnd, y);
            ctx.stroke();
        });

        // Draw vertical measure lines.
        let topLineY = yForPitch(11);
        let botLineY = yForPitch(3);
        measureDivisions.forEach(div => {
            if (div === 1) return;
            let x = STAFF_LEFT + div * BEAT_WIDTH;
            ctx.beginPath();
            ctx.moveTo(x, topLineY);
            ctx.lineTo(x, botLineY);
            ctx.stroke();
        });

        // Draw notes (or rests for beats 2+)
        for (let b = 0; b < NUM_BEATS; b++) {
            if (staffNotes[b]) {
                drawNote(staffNotes[b], b, (b === selectedBeat));
            } else if (b > 0) {
                drawRest(b);
            }
        }

        ctx.save();
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(thickBarX, topLineY);
        ctx.lineTo(thickBarX, botLineY);
        ctx.stroke();
        ctx.restore();
    }

    function drawRest(beat) {
        const REST_OFFSET = 10;
        let xCenter = STAFF_LEFT + (beat + 0.5) * BEAT_WIDTH + REST_OFFSET;
        let yCenter = yForPitch(7);
        ctx.save();
        ctx.fillStyle = "#000";
        ctx.font = "60px italic serif";
        ctx.fillText("ùÑΩ", xCenter - 24, yCenter + 18);
        ctx.restore();
    }

    // Draw ledger lines for notes outside the staff range
    function drawLedgerLines(note, x, radius) {
        ctx.save();
        ctx.strokeStyle = "#000";
        if (note.pitch < 3) {
            for (let p = 1; p >= note.pitch; p -= 2) {
                let ly = yForPitch(p);
                ctx.beginPath();
                ctx.moveTo(x - radius - 4, ly);
                ctx.lineTo(x + radius + 4, ly);
                ctx.stroke();
            }
        }
        if (note.pitch > 11) {
            for (let p = 13; p <= note.pitch; p += 2) {
                let ly = yForPitch(p);
                ctx.beginPath();
                ctx.moveTo(x - radius - 4, ly);
                ctx.lineTo(x + radius + 4, ly);
                ctx.stroke();
            }
        }
        ctx.restore();
    }

    // Draw a quarter note with stem and accidental styling
    function drawNote(note, beat, isSelected) {
        let xCenter = STAFF_LEFT + (beat + 0.5) * BEAT_WIDTH;
        let yCenter = yForPitch(note.pitch);

        if (isSelected) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 150, 255, 0.3)";
            ctx.beginPath();
            ctx.arc(xCenter, yCenter, NOTE_RADIUS + 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        drawLedgerLines(note, xCenter, NOTE_RADIUS);

        ctx.save();
        ctx.beginPath();
        ctx.ellipse(xCenter, yCenter, NOTE_RADIUS, NOTE_RADIUS + 3, 1, 0, 2 * Math.PI);
        ctx.fill();

        const stemLength = 55;
        ctx.beginPath();
        if (note.pitch >= 7) {
            ctx.moveTo(xCenter - NOTE_RADIUS - 2, yCenter);
            ctx.lineTo(xCenter - NOTE_RADIUS - 2, yCenter + stemLength);
        } else {
            ctx.moveTo(xCenter + NOTE_RADIUS + 2, yCenter);
            ctx.lineTo(xCenter + NOTE_RADIUS + 2, yCenter - stemLength);
        }
        ctx.stroke();

        if (note.accidental && note.accidental !== "natural") {
            ctx.font = "32px italic serif";
            ctx.fillStyle = "#000";
            let symbol;
            let yAdd;
            if (note.accidental === "sharp") {
                yAdd = 11;
                symbol = "#";
            } else {
                yAdd = 5
                symbol = "‚ô≠";
            }
            ctx.fillText(symbol, xCenter - (NOTE_RADIUS + 19), yCenter + yAdd);
        }

        if (
            note.tied &&
            beat > 0 &&
            staffNotes[beat - 1] &&
            staffNotes[beat - 1].pitch === note.pitch &&
            staffNotes[beat - 1].accidental === note.accidental
        ) {
            // Get centers for the previous and current notes.
            let prevNote = staffNotes[beat - 1];
            let xPrevCenter = STAFF_LEFT + (beat - 0.5) * BEAT_WIDTH;
            let xCurrCenter = STAFF_LEFT + (beat + 0.5) * BEAT_WIDTH;
            let yPrevCenter = yForPitch(prevNote.pitch);
            let yCurrCenter = yForPitch(note.pitch);

            // Determine tie direction: for higher notes, draw the tie above; for lower, below.
            let tieDirection = (note.pitch >= 7) ? "up" : "down";
            let offset = 2; // extra separation from the note head edge

            // Calculate attachment points based on tie direction.
            let y1 =
                tieDirection === "up"
                    ? yPrevCenter - (NOTE_RADIUS + offset)
                    : yPrevCenter + (NOTE_RADIUS + offset);
            let y2 =
                tieDirection === "up"
                    ? yCurrCenter - (NOTE_RADIUS + offset)
                    : yCurrCenter + (NOTE_RADIUS + offset);
            let x1 = xPrevCenter;
            let x2 = xCurrCenter;

            // Control point for the curve.
            let cpX = (x1 + x2) / 2;
            let arcHeight = 25;
            let cpY =
                tieDirection === "up"
                    ? Math.min(y1, y2) - arcHeight
                    : Math.max(y1, y2) + arcHeight;

            // Thickness in the middle of the tie.
            let tieThickness = 8;

            ctx.save();
            ctx.fillStyle = "#000";
            ctx.beginPath();
            // Draw the primary edge of the tie.
            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo(cpX, cpY, x2, y2);
            // Draw the opposite edge, offset by tieThickness.
            if (tieDirection === "up") {
                ctx.quadraticCurveTo(cpX, cpY + tieThickness, x1, y1);
            } else {
                ctx.quadraticCurveTo(cpX, cpY - tieThickness, x1, y1);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        ctx.restore();
    }

    /***** Event Handling: Pointer Down/Move/Up *****/
    canvas.addEventListener("mousedown", pointerDown);
    canvas.addEventListener("touchstart", pointerDown);
    function pointerDown(e) {
        e.preventDefault();
        let pos = getCanvasPos(e);
        let beat = beatForX(pos.x);
        if (beat < 1) return; // Ignore notation-only area

        if (staffNotes[beat]) {
            // There is already a note at this beat.
            // Compute its center (using its pitch) to see if we clicked directly on it.
            let note = staffNotes[beat];
            let xCenter = STAFF_LEFT + (beat + 0.5) * BEAT_WIDTH;
            let yCenter = yForPitch(note.pitch);
            let dx = pos.x - xCenter;
            let dy = pos.y - yCenter;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let threshold = NOTE_RADIUS + 5; // Adjust this value as needed

            if (distance <= threshold) {
                // Tapped directly on the note head:
                let chainIndices = getChainIndices(beat);
                selectedBeat = chainIndices[0];
                dragBeat = selectedBeat;
                drawStaff();
                playTone(note, false);
            } else {
                // Clicked away from the center of the note head:
                // Update the entire chain to the new pitch (and clear accidentals)
                let newPitch = pitchForY(pos.y);
                let chainIndices = getChainIndices(beat);
                chainIndices.forEach(i => {
                    staffNotes[i].pitch = newPitch;
                    staffNotes[i].accidental = "natural";
                });
                selectedBeat = chainIndices[0];
                dragBeat = selectedBeat;
                drawStaff();
                playTone(staffNotes[chainIndices[0]], false);
            }
        } else {
            // No note exists at this beat: create a new note using currentAccidental.
            let pitch = pitchForY(pos.y);
            staffNotes[beat] = { pitch, accidental: currentAccidental };
            selectedBeat = beat;
            dragBeat = beat;
            drawStaff();
            playTone(staffNotes[beat], false);
        }
        isDragging = true;
    }
    canvas.addEventListener("mousemove", pointerMove);
    canvas.addEventListener("touchmove", pointerMove);
    function pointerMove(e) {
        if (!isDragging || dragBeat === null) return;
        e.preventDefault();
        let pos = getCanvasPos(e);
        let newPitch = pitchForY(pos.y);

        let chainIndices = getChainIndices(dragBeat);
        if (chainIndices.length === 0) return;

        // Only update if the pitch has actually changed from the chain's starting note.
        let currentPitch = staffNotes[chainIndices[0]].pitch;
        if (newPitch !== currentPitch) {
            chainIndices.forEach(i => {
                staffNotes[i].pitch = newPitch;
                staffNotes[i].accidental = "natural"; // clear accidental when dragging
            });
            playTone(staffNotes[chainIndices[0]], true);
            drawStaff();
        }
    }
    canvas.addEventListener("mouseup", pointerUp);
    canvas.addEventListener("touchend", pointerUp);
    function pointerUp(e) {
        if (isDragging) {
            isDragging = false;
            dragBeat = null;
        }
    }
    window.addEventListener("keydown", e => {
        if (selectedBeat < 1 || selectedBeat === -1) return;
        let chainIndices = getChainIndices(selectedBeat);
        switch (e.key) {
            case "ArrowUp":
                chainIndices.forEach(i => {
                    staffNotes[i].pitch = Math.min(15, staffNotes[i].pitch + 1);
                    staffNotes[i].accidental = "natural"; // reset accidental when moving
                });
                playTone(staffNotes[chainIndices[0]]);
                drawStaff();
                break;
            case "ArrowDown":
                chainIndices.forEach(i => {
                    staffNotes[i].pitch = Math.max(1, staffNotes[i].pitch - 1);
                    staffNotes[i].accidental = "natural"; // reset accidental when moving
                });
                playTone(staffNotes[chainIndices[0]]);
                drawStaff();
                break;
            case "ArrowLeft":
                for (let b = selectedBeat - 1; b >= 2; b--) {
                    if (staffNotes[b]) {
                        selectedBeat = b;
                        playTone(staffNotes[b], true);
                        drawStaff();
                        break;
                    }
                }
                break;
            case "ArrowRight":
                for (let b = selectedBeat + 1; b < NUM_BEATS; b++) {
                    if (staffNotes[b]) {
                        selectedBeat = b;
                        playTone(staffNotes[b], true);
                        drawStaff();
                        break;
                    }
                }
                break;
        }
    });

    /***** Playback Controls *****/
    function stopPlayback() {
        playTimeouts.forEach(id => clearTimeout(id));
        playTimeouts = [];
        isPlaying = false;
    }
    function playStaff() {
        stopPlayback();
        isPlaying = true;
        const tempo = 120;
        const beatDuration = 60 / tempo;
        let b = 1;
        while(b < NUM_BEATS) {
            if (staffNotes[b] && !staffNotes[b].tied) {
                let note = staffNotes[b];
                let chainLength = 1;
                while(b + chainLength < NUM_BEATS &&
                staffNotes[b + chainLength] &&
                staffNotes[b + chainLength].tied &&
                staffNotes[b + chainLength].pitch === note.pitch &&
                staffNotes[b + chainLength].accidental === note.accidental) {
                    chainLength++;
                }
                let duration = beatDuration * 0.9 * chainLength;
                let timeoutId = setTimeout(() => {
                    playTone(note, false, duration);
                }, (b - 1) * beatDuration * 1000);
                playTimeouts.push(timeoutId);
                b += chainLength;
                continue;
            }
            b++;
        }
    }
    document.getElementById("instrumentSelect").addEventListener("change", (e) => {
        currentInstrument = e.target.value;
    });
    document.getElementById("playButton").addEventListener("click", playStaff);
    document.getElementById("stopButton").addEventListener("click", stopPlayback);

    /***** Note Control Functionality *****/
    document.getElementById("sharpButton").addEventListener("click", () => {
        if (selectedBeat >= 2 && staffNotes[selectedBeat]) {
            let chainIndices = getChainIndices(selectedBeat);
            chainIndices.forEach(i => {
                staffNotes[i].accidental = "sharp";
            });
            drawStaff();
        }
    });
    document.getElementById("flatButton").addEventListener("click", () => {
        if (selectedBeat >= 2 && staffNotes[selectedBeat]) {
            let chainIndices = getChainIndices(selectedBeat);
            chainIndices.forEach(i => {
                staffNotes[i].accidental = "flat";
            });
            drawStaff();
        }
    });
    document.getElementById("naturalButton").addEventListener("click", () => {
        if (selectedBeat >= 2 && staffNotes[selectedBeat]) {
            let chainIndices = getChainIndices(selectedBeat);
            chainIndices.forEach(i => {
                staffNotes[i].accidental = "natural";
            });
            drawStaff();
        }
    });
    document.getElementById("deleteButton").addEventListener("click", () => {
        if (selectedBeat >= 2 && staffNotes[selectedBeat]) {
            let chainIndices = getChainIndices(selectedBeat);
            chainIndices.forEach(i => {
                staffNotes[i] = null;
            });
            selectedBeat = -1;
            drawStaff();
        }
    });
    function holdLonger() {
        if (selectedBeat < 1 || !staffNotes[selectedBeat]) {
            alert("Select a note to hold.");
            return;
        }
        let chainIndices = getChainIndices(selectedBeat);
        let lastIndex = chainIndices[chainIndices.length - 1];
        if (lastIndex >= NUM_BEATS - 1) {
            alert("Cannot extend beyond the last beat.");
            return;
        }
        let baseNote = staffNotes[lastIndex];
        staffNotes[lastIndex + 1] = {
            pitch: baseNote.pitch,
            accidental: baseNote.accidental,
            tied: true
        };
        selectedBeat = lastIndex + 1;
        drawStaff();
        playTone(staffNotes[selectedBeat], true);
    }
    document.getElementById("holdLongerButton").addEventListener("click", holdLonger);
    function holdShorter() {
        if (selectedBeat < 1 || !staffNotes[selectedBeat]) {
            alert("No note selected to shorten.");
            return;
        }
        let chainIndices = getChainIndices(selectedBeat);
        if (chainIndices.length === 1) {
            alert("No held note to shorten.");
        } else {
            let lastIndex = chainIndices[chainIndices.length - 1];
            staffNotes[lastIndex] = null;
            // Optionally update selectedBeat to the new end of the chain.
            selectedBeat = chainIndices[chainIndices.length - 2];
            drawStaff();
        }
    }
    document.getElementById("holdShorterButton").addEventListener("click", holdShorter);

    /***** Clear Button *****/
    document.getElementById("clearButton").addEventListener("click", () => {
        if (staffNotes.slice(2).some(n => n !== null) &&
            !confirm("This will clear your current composition. Continue?")) {
            return;
        }
        staffNotes = new Array(NUM_BEATS).fill(null);
        selectedBeat = -1;
        drawStaff();
    });

    /***** Submission Handling & Pagination *****/
    const submissionForm = document.getElementById("submissionForm");
    const submissionErrorDiv = document.getElementById("submissionError");
    const submissionsTableBody = document.querySelector("#submissionsTable tbody");
    const currentPageSpan = document.getElementById("currentPage");

    // Fetch submissions with pagination. (Ensure your backend supports Pageable.)
    function fetchSubmissions() {
        fetch(`/api/submissions?page=${currentPage}&size=${PAGE_SIZE}`)
            .then(response => response.json())
            .then(data => {
                updateSubmissionsTable(data.content);
                currentPageSpan.textContent = `Page ${currentPage + 1}`;

                document.getElementById("nextPage").disabled = currentPage >= data.page.totalPages - 1;
                document.getElementById("prevPage").disabled = currentPage <= 0;
            })
            .catch(error => {
                console.error("Error fetching submissions:", error);
            });
    }

    // Update the submissions table
    function updateSubmissionsTable(submissions) {
        submissionsTableBody.innerHTML = "";
        submissions.forEach(sub => {
            submissionsTableBody.appendChild(createSubmissionRow(sub));
        });
    }

    // Create a table row for a submission
    function createSubmissionRow(submission) {
        let tr = document.createElement("tr");

        let tdName = document.createElement("td");
        tdName.textContent = submission.name;

        let tdTitle = document.createElement("td");
        tdTitle.textContent = submission.title;

        let tdComment = document.createElement("td");
        tdComment.textContent = submission.comment;

        let tdActions = document.createElement("td");
        let playBtn = document.createElement("button");
        playBtn.textContent = "‚ñ∂";
        playBtn.addEventListener("click", () => playSubmission(submission));
        let loadBtn = document.createElement("button");
        loadBtn.textContent = "Load";
        loadBtn.addEventListener("click", () => loadSubmission(submission));

        tdActions.appendChild(playBtn);
        tdActions.appendChild(loadBtn);
        tr.appendChild(tdName);
        tr.appendChild(tdTitle);
        tr.appendChild(tdComment);
        tr.appendChild(tdActions);

        return tr;
    }

    // Play a submission‚Äôs song
    function playSubmission(submission) {
        let song;
        try {
            song = JSON.parse(submission.song);
        } catch (err) {
            return alert("Invalid song data in submission.");
        }
        stopPlayback();
        const tempo = 120;
        const beatDuration = 60 / tempo;
        let b = 1;
        while (b < song.length) {
            if (song[b] && !song[b].tied) {
                let note = song[b];
                let chainLength = 1;
                while (b + chainLength < song.length &&
                song[b + chainLength] &&
                song[b + chainLength].tied &&
                song[b + chainLength].pitch === note.pitch &&
                song[b + chainLength].accidental === note.accidental) {
                    chainLength++;
                }
                let duration = beatDuration * 0.9 * chainLength;
                let timeoutId = setTimeout(() => {
                    playTone(note, false, duration);
                }, (b - 1) * beatDuration * 1000);
                playTimeouts.push(timeoutId);
                b += chainLength;
                continue;
            }
            b++;
        }
        isPlaying = true;
    }

    // Load a submission‚Äôs song into the work area
    function loadSubmission(submission) {
        if (staffNotes.slice(2).some(n => n !== null) &&
            !confirm("This will clear your current composition. Continue?")) {
            return;
        }
        let song;
        try {
            song = JSON.parse(submission.song);
        } catch (err) {
            return alert("Invalid song data in submission.");
        }
        staffNotes = new Array(NUM_BEATS).fill(null);
        for (let b = 0; b < NUM_BEATS; b++) {
            if (song[b]) {
                staffNotes[b] = { ...song[b] };
            }
        }
        if (submission.instrument) {
            currentInstrument = submission.instrument;
            document.getElementById("instrumentSelect").value = currentInstrument;
        }
        selectedBeat = -1;
        drawStaff();
    }

    // Submission Form: Only name is required; if title, comment, or composition are missing, show a confirm alert.
    submissionForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const name = document.getElementById("submitName").value.trim();
        const title = document.getElementById("submitTitle").value.trim();
        const comment = document.getElementById("submitComment").value.trim();

        if (!name) {
            alert("Guest name is required.");
            return;
        }

        let missingFields = [];
        if (!title) missingFields.push("song title");
        if (!comment) missingFields.push("message");
        let compositionEmpty = staffNotes.slice(2).every(n => n === null);
        if (compositionEmpty) missingFields.push("composition");

        if (missingFields.length > 0) {
            if (!confirm("The following fields are missing: " + missingFields.join(", ") + ". Do you want to proceed?")) {
                return;
            }
        }

        const submissionData = {
            name: name,
            title: title,
            song: JSON.stringify(staffNotes),
            comment: comment,
            instrument: currentInstrument
        };

        fetch("/api/submissions/" + encodeURIComponent(name), {
            method: "PUT",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(submissionData)
        })
            .then(response => {
                if (!response.ok) {
                    if (response.status === 409) {
                        throw new Error("A submission with this guest name already exists. Please choose a unique name.");
                    } else {
                        throw new Error("Error submitting composition.");
                    }
                }
                return response.json();
            })
            .then(data => {
                submissionErrorDiv.textContent = "";
                submissionForm.reset();
                // Clear the composition if necessary.
                if (staffNotes.slice(2).some(n => n !== null)) {
                    staffNotes = new Array(NUM_BEATS).fill(null);
                    selectedBeat = -1;
                    drawStaff();
                }
                // Refresh the submissions table (pagination will update automatically)
                fetchSubmissions();
            })
            .catch(error => {
                submissionErrorDiv.textContent = error.message;
            });
    });

    // Pagination Controls
    document.getElementById("prevPage").addEventListener("click", () => {
        if (currentPage > 0) {
            currentPage--;
            fetchSubmissions();
        }
    });
    document.getElementById("nextPage").addEventListener("click", () => {
        currentPage++;
        fetchSubmissions();
    });

    // Initial fetch and draw
    fetchSubmissions();
    drawStaff();
</script>
</body>
</html>
